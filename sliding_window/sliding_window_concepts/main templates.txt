ğŸ”¹ 1ï¸âƒ£ Fixed Size Sliding Window (Window Size = K)

ğŸ‘‰ Used when:

â€œFind maximum/minimum/sum of subarray of size kâ€

â€œFirst negative in every window of size kâ€

â€œMaximum sum of size kâ€

ğŸ§  Template (Java)
public int slidingWindowFixed(int[] arr, int k) {
    int n = arr.length;

    int i = 0;     // left pointer
    int j = 0;     // right pointer
    int sum = 0;   // example variable (depends on problem)
    int ans = Integer.MIN_VALUE;

    while (j < n) {

        // 1. Add current element into window
        sum += arr[j];

        // 2. When window size < k â†’ just expand
        if (j - i + 1 < k) {
            j++;
        }

        // 3. When window size == k â†’ calculate answer
        else if (j - i + 1 == k) {

            ans = Math.max(ans, sum);  // calculation step

            // 4. Remove left element before sliding
            sum -= arr[i];

            i++;   // slide window
            j++;
        }
    }

    return ans;
}

ğŸ”¹ 2ï¸âƒ£ Variable Size Sliding Window (Longest Subarray Type)

ğŸ‘‰ Used when:

â€œLongest subarray with sum â‰¤ kâ€

â€œLongest substring without repeating charactersâ€

â€œAt most k distinct charactersâ€

â€œSmallest subarray with sum â‰¥ kâ€

ğŸ§  General Template
public int slidingWindowVariable(int[] arr, int k) {
    int n = arr.length;

    int i = 0;
    int j = 0;
    int sum = 0;
    int ans = 0;

    while (j < n) {

        // 1. Expand window
        sum += arr[j];

        // 2. If condition is invalid â†’ shrink window
        while (sum > k) {    // condition depends on problem
            sum -= arr[i];
            i++;
        }

        // 3. Update answer
        ans = Math.max(ans, j - i + 1);

        j++;
    }

    return ans;
}

ğŸ”¹ 3ï¸âƒ£ Sliding Window with HashMap (Strings / Distinct Elements)

ğŸ‘‰ Used when:

Longest substring without repeating characters

At most K distinct characters

Anagram problems

Count distinct elements

ğŸ§  Template for String Problems
public int slidingWindowString(String s) {

    int i = 0;
    int j = 0;
    int n = s.length();
    int ans = 0;

    HashMap<Character, Integer> map = new HashMap<>();

    while (j < n) {

        char ch = s.charAt(j);

        // Add current character
        map.put(ch, map.getOrDefault(ch, 0) + 1);

        // Shrink window if invalid
        while (map.get(ch) > 1) {  // condition changes per problem
            char leftChar = s.charAt(i);
            map.put(leftChar, map.get(leftChar) - 1);

            if (map.get(leftChar) == 0)
                map.remove(leftChar);

            i++;
        }

        // Update answer
        ans = Math.max(ans, j - i + 1);

        j++;
    }

    return ans;
}
